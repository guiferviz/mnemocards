{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>      In addition to helping you memorise, this code helps you do other things that I don't remember... </p> <p> Documentation:      https://guiferviz.com/mnemocards </p> <p> Source Code:      https://github.com/guiferviz/mnemocards </p> <p> </p>"},{"location":"#what-is-this","title":"\ud83e\udd14 What is this?","text":"<p>Mnemocards is a Python package originally intended for creating Anki flashcards from text files. It allows users to define a series of steps to read flashcards from any source, transform them and export them to different formats such as Anki APKG packages.</p> <p>Mnemocards is designed to be fully extensible, which means that users can create their own tasks and customize the card generation process to their specific needs. Indeed, Mnemocards has the versatility to be used for purposes beyond generating Anki decks.</p>"},{"location":"#features","title":"\ud83c\udff7\ufe0f Features","text":"<ul> <li>Generate Anki APKG packages that you can later import into the Anki app.</li> <li>Auto generate pronunciations from the words that you are learning in any language supported by Google Translator.</li> <li>Generate flashcards from text files that can be stored in Git repositories. This brings several positive things:<ul> <li>Keep track of changes.</li> <li>Edit cards using your favourite text editor. I  VIM.</li> <li>Easily share and collaborate with others. If you know how to work with Git you can create forks and pull requests to existing repositories.</li> </ul> </li> <li>Fully extensible architecture that allows you to define custom transformations on a list of notes.<ul> <li>Possibility to implement another way of exporting flashcards to other   existing flashcards apps. Contributions are welcome.</li> <li>Possibility to create search indexes, analyze your collection of cards,   create visualizations, clustering, analyze how the cards relate to each   other... Contributions are welcome.</li> </ul> </li> </ul>"},{"location":"#installation","title":"\u2699\ufe0f Installation","text":"<p>To get started with Mnemocards, you'll need to have Python &gt;= 3.10 installed on your computer. Then, you can install Mnemocards using <code>pip</code>:</p> <pre><code>$ pip install --pre mnemocards\n</code></pre> <p>You can check that the installation went well by executing the following command:</p> <pre><code>$ mnemocards --version\n\u2554\u2566\u2557\u2554\u2557\u2554\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2500\u2510\u252c\u2500\u2510\u250c\u252c\u2510\u250c\u2500\u2510\n\u2551\u2551\u2551\u2551\u2551\u2551\u2551\u2563 \u2551\u2551\u2551\u2551 \u2551\u2502  \u251c\u2500\u2524\u251c\u252c\u2518 \u2502\u2502\u2514\u2500\u2510\n\u2569 \u2569\u255d\u255a\u255d\u255a\u2550\u255d\u2569 \u2569\u255a\u2550\u255d\u2514\u2500\u2518\u2534 \u2534\u2534\u2514\u2500\u2500\u2534\u2518\u2514\u2500\u2518 X.Y.Z\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 &lt;A super mega funny joke here&gt; \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>If the joke made you laugh you can continue with this tutorial, otherwise this program is not for you and you should consider other alternatives.</p>"},{"location":"#how-it-works","title":"\u2753How it works?","text":"<p>Once you have Mnemocards installed, you can start creating your own flashcards. Let's start creating our own vocabulary Anki cards.</p> <p>Imagine you are learning Spanish and you have a list of vocabulary like this:</p> English Spanish Hello Hola Bye Adi\u00f3s <p>If you want to use Mnemocards to generate Anki cards for those words the first thing you need to do is to create a CSV file like the following:</p> vocabulary.csv<pre><code>your_language_word,language_you_learn_word,id\nHello,Hola,9a6c9728-7f86-4e3f-9dec-a2f804bd0a76\nBye,Adi\u00f3s,e600a85a-8a6b-4449-a188-f7401dc69d6b\n</code></pre> <p>A CSV file is a text file that represents a table. The first line is the header of the table, after that header line we have one line per row. Each column is separated from the other with a column. CSV stands for Comma-Separated Values.</p> <p>The first column contains the word in your native language, in this case English. The second row is the word in the language you are learning, Spanish. The last column is a randomly generated ID.</p> <p>Why do we need an ID?</p> <p>IDs are used to uniquely identify a note in Anki. We can use the Spanish word as an ID, but if you start studing a card and you want to make an edit later the card will be considered as a complete new one, loosing your progress.</p> <p>For example, imagine you write Adios and after several days of study you realise that your miss the accent. If you chage Adios to Adi\u00f3s the ID of that note will be different. To avoid this kind of problems I decided to include an ID column.</p> <p>Mnemocards uses a configuration file named <code>mnemocards.yaml</code> to define the steps that will be used to process our flashcards. In this file, you can specify the tasks that you want to use, the order in which they will be executed, and any necessary parameters.</p> <p>Here is an example of a simple configuration file that reads in a CSV file containing vocabulary data, and then generates an Anki APKG package:</p> mnemocards.yaml<pre><code>steps:\n# Read a CSV file with our spanish vocabulary.\n- type: ReadCsv\npath: vocabulary.csv\n# Tag the generated notes and assign them to an Anki deck.\n- type: mnemocards_anki.Configure\ntags: spanish, languages\ndeck:\nname: Spanish\nid: 429d2604-ca8a-4c0a-9b03-38d1df5b9af7\nnote_type: mnemocards_anki.VocabularyNoteType\n# Pronounce the spanish words using Google Translator.\n- type: mnemocards_anki.Pronounce\nlanguage: es\nattribute_to_pronounce: language_you_learn_word\n# Save the Anki package.\n- type: mnemocards_anki.Package\n# Show the generated tasks in the terminal.\n# Do not print the note id, the note_type and the deck to avoid cluttering the terminal.\n- type: Print\nignore_regex: id|note_type|deck\n# Show some stats of the generation process.\n- type: Stats\n</code></pre> <p>You can run the configuration file using the following command:</p> <pre><code>$ mnemocards run mnemocards.yml\n</code></pre> <p>This will execute the steps in the configuration file, and will generate an Anki package named <code>out.apkg</code> by default. The generated file is in the same directory as your <code>mnemocards.yaml</code>.</p> <p>If you import the <code>apkg</code> file to Anki you can start studying Spanish:</p> <p></p>"},{"location":"#what-is-next","title":"\ud83e\udd13 What is next?","text":"<p>If you have come this far, it is because you may have found this project interesting. Consider visiting the documentation, in particular the examples section to learn more.</p> <p>As mentioned above, Mnemocards is fully extensible, so any data source you miss or any processing or analysis you want to do on your cards is more than welcome. Feel free to post your idea to start a discussion. Do not worry if you do not know how to program, there may be someone who can do it for you.</p> <p>Enjoy learning!!!</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is inspired on Keep a Changelog. This project uses Semantic Versioning.</p>"},{"location":"changelog/#100b0-15-04-2023","title":"1.0.0b0 - 15-04-2023","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Improving docs.</li> <li>Functional test of examples.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Readers are now independent tasks. Instead of having a File task that uses readers we have a ReadCsv task, a ReadJson task... One per each format. This removes a lot of complexity.</li> <li>Paths are relative to the config file they are defined.</li> </ul>"},{"location":"changelog/#100a1-02-04-2023","title":"1.0.0a1 - 02-04-2023","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Loading files relative to the configuration file.</li> <li>Adding <code>mnemocards_anki.Pronounce</code>: task for pronouncing text using Google Translator.</li> <li>Adding more docs.</li> </ul>"},{"location":"changelog/#100a0-06-03-2023","title":"1.0.0a0 - 06-03-2023","text":"<p>A complete rewrite of the mnemocards package. Some features are missing.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>You can contribute in many ways:</p> <ul> <li> <p>Report bugs using GitHub issues.</p> </li> <li> <p>Fix bugs listed in the GitHub issues page. Look for those marked with a \"Good first issue\" if you are looking for something easy.</p> </li> <li> <p>Implement features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p> </li> <li> <p>Write documentation. Update/add docstrings in the Python code, contribute to any file inside the <code>docs</code> directory, or even create blog posts in your favourite blogging platform.</p> </li> <li> <p>Submit feedback using GitHub issues. Issues are not necessarily for bugs, you can use them to post any kind of ideas/feedback or just thank the authors for their work .</p> </li> </ul>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li> <p>The pull request should include tests.</p> </li> <li> <p>If you are adding/removing/modifying some functionality, please describe your contribution in <code>CHANGELOG.md</code>.</p> </li> <li> <p>The pull request should work for Python all the supported Python versions.</p> </li> </ol>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#why-use-text-files-for-flashcards-instead-of-binary-formats-or-manual-creation-in-anki","title":"Why use text files for flashcards instead of binary formats or manual creation in Anki?","text":"<p>Reading flashcards from text files has several advantages over binary formats or manually creating cards in the Anki app. Text files are easily readable and editable by humans. This means that users can easily understand and modify the flashcard content using common text editors, and also can use version control systems like Git to track changes and collaborate with others.</p>"},{"location":"faq/#how-can-i-create-custom-mnemocards-tasks","title":"How can I create custom Mnemocards tasks?","text":"<p>The plugins example contains a lot of information about this.</p>"},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"apis/mnemocards/","title":"mnemocards","text":""},{"location":"apis/mnemocards/#mnemocards","title":"<code>mnemocards</code>","text":"<p>Top-level package for Mnemocards.</p>"},{"location":"apis/mnemocards/#mnemocards.cli","title":"<code>cli</code>","text":""},{"location":"apis/mnemocards/#mnemocards.cli.CLI","title":"<code>CLI</code>","text":"Source code in <code>src/mnemocards/cli.py</code> <pre><code>class CLI:\ndef __init__(self, version: bool = False, log_level: str = \"CRITICAL\"):\nself._init_console()\nself._init_logging(log_level)\nself._greet()\nif version:\nraise SystemExit()\ndef _init_console(self):\nself._console = Console(\ntheme=Theme(\n{\n\"logo\": \"bold green\",\n\"version\": \"bold yellow\",\n\"info\": \"green\",\n\"warning\": \"bold yellow\",\n\"joke\": \"bold italic blue\",\n\"log.time\": \"yellow\",\n\"logging.level.info\": \"bold blue\",\n}\n)\n)\ndef _init_logging(self, log_level: str):\nself._log_level = log_level\nlogging.basicConfig(\nlevel=log_level,\nformat=\"%(message)s\",\ndatefmt=\"%H:%M:%S\",\nhandlers=[\nRichHandler(\nshow_level=True,\nshow_time=True,\nrich_tracebacks=True,\nmarkup=True,\nconsole=self._console,\n)\n],\n)\ndef _greet(self):\nlogo = f\"[logo]{_LOGO}\"\nversion = f\"[version]{mnemocards.__version__}\"\nself._console.print(f\"{logo} {version}\")\njoke = random.choice(_JOKES)\nself._console.print(Panel.fit(f\"[joke]{joke}\"))\ndef run(\nself, directory: PathLike = \".\", filename: str = \"mnemocards.yaml\"\n) -&gt; int:\n\"\"\"Run a given Mnemocard task.\n        Args:\n            directory: Directory to search for a Mnemocards Task definition.\n            filename: File name with the Mnemocards Task configuration.\n        \"\"\"\nself._console.print(\"[info]Hi! :waving_hand:\")\ntry:\ncreate_and_run_task(directory, filename)\nexcept Exception:\nself._console.print_exception(\nshow_locals=self._log_level == \"DEBUG\"\n)\nself._console.print(\n\"[warning]Although things didn't go as well as we expected,\"\n\" hope to see you soon! :call_me_hand:\"\n)\nreturn -1\nself._console.print(\"See you soon! :call_me_hand:\")\nreturn 0\ndef id(self):\nid_ = str(uuid.uuid4())\nself._console.print(id_)\n</code></pre>"},{"location":"apis/mnemocards/#mnemocards.cli.CLI.run","title":"<code>run(directory='.', filename='mnemocards.yaml')</code>","text":"<p>Run a given Mnemocard task.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>PathLike</code> <p>Directory to search for a Mnemocards Task definition.</p> <code>'.'</code> <code>filename</code> <code>str</code> <p>File name with the Mnemocards Task configuration.</p> <code>'mnemocards.yaml'</code> Source code in <code>src/mnemocards/cli.py</code> <pre><code>def run(\nself, directory: PathLike = \".\", filename: str = \"mnemocards.yaml\"\n) -&gt; int:\n\"\"\"Run a given Mnemocard task.\n    Args:\n        directory: Directory to search for a Mnemocards Task definition.\n        filename: File name with the Mnemocards Task configuration.\n    \"\"\"\nself._console.print(\"[info]Hi! :waving_hand:\")\ntry:\ncreate_and_run_task(directory, filename)\nexcept Exception:\nself._console.print_exception(\nshow_locals=self._log_level == \"DEBUG\"\n)\nself._console.print(\n\"[warning]Although things didn't go as well as we expected,\"\n\" hope to see you soon! :call_me_hand:\"\n)\nreturn -1\nself._console.print(\"See you soon! :call_me_hand:\")\nreturn 0\n</code></pre>"},{"location":"apis/mnemocards/#mnemocards.task","title":"<code>task</code>","text":""},{"location":"apis/mnemocards/#mnemocards.task.Task","title":"<code>Task</code>","text":"<p>         Bases: <code>utils.PydanticType</code></p> <p>Basic unit of work.</p> Source code in <code>src/mnemocards/task.py</code> <pre><code>class Task(utils.PydanticType):\n\"\"\"Basic unit of work.\"\"\"\ndef start(self):\n\"\"\"Method called before processing any note.\"\"\"\npass\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\n\"\"\"Method that contains the processing logic of the task.\n        Arguments:\n            notes: An iterable of notes to process.\n        \"\"\"\nfor i in notes:\nnote = self.process_one(i)\nif note:\nyield note\ndef process_one(self, note: NoteDict) -&gt; NoteDict:\n\"\"\"Method called one per note.\n        !!! note\n            If you want to use this method you should not overwrite the process\n            method. Otherwise this method will not be called.\n        Arguments:\n            note: A note to process.\n        \"\"\"\nreturn note\ndef end(self):\n\"\"\"Method called after processing all the notes.\"\"\"\npass\n</code></pre>"},{"location":"apis/mnemocards/#mnemocards.task.Task.end","title":"<code>end()</code>","text":"<p>Method called after processing all the notes.</p> Source code in <code>src/mnemocards/task.py</code> <pre><code>def end(self):\n\"\"\"Method called after processing all the notes.\"\"\"\npass\n</code></pre>"},{"location":"apis/mnemocards/#mnemocards.task.Task.process","title":"<code>process(notes)</code>","text":"<p>Method that contains the processing logic of the task.</p> <p>Parameters:</p> Name Type Description Default <code>notes</code> <code>Iterable[NoteDict]</code> <p>An iterable of notes to process.</p> required Source code in <code>src/mnemocards/task.py</code> <pre><code>def process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\n\"\"\"Method that contains the processing logic of the task.\n    Arguments:\n        notes: An iterable of notes to process.\n    \"\"\"\nfor i in notes:\nnote = self.process_one(i)\nif note:\nyield note\n</code></pre>"},{"location":"apis/mnemocards/#mnemocards.task.Task.process_one","title":"<code>process_one(note)</code>","text":"<p>Method called one per note.</p> <p>Note</p> <p>If you want to use this method you should not overwrite the process method. Otherwise this method will not be called.</p> <p>Parameters:</p> Name Type Description Default <code>note</code> <code>NoteDict</code> <p>A note to process.</p> required Source code in <code>src/mnemocards/task.py</code> <pre><code>def process_one(self, note: NoteDict) -&gt; NoteDict:\n\"\"\"Method called one per note.\n    !!! note\n        If you want to use this method you should not overwrite the process\n        method. Otherwise this method will not be called.\n    Arguments:\n        note: A note to process.\n    \"\"\"\nreturn note\n</code></pre>"},{"location":"apis/mnemocards/#mnemocards.task.Task.start","title":"<code>start()</code>","text":"<p>Method called before processing any note.</p> Source code in <code>src/mnemocards/task.py</code> <pre><code>def start(self):\n\"\"\"Method called before processing any note.\"\"\"\npass\n</code></pre>"},{"location":"apis/mnemocards_anki/","title":"mnemocards_anki","text":""},{"location":"apis/mnemocards_anki/#mnemocards_anki","title":"<code>mnemocards_anki</code>","text":"<p>Mnemocards package with Anki related tasks.</p>"},{"location":"apis/mnemocards_anki/#mnemocards_anki.package","title":"<code>package</code>","text":""},{"location":"apis/mnemocards_anki/#mnemocards_anki.package.Package","title":"<code>Package</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Create an Anki package.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the output <code>*.apkg</code> file.</p> Source code in <code>src/mnemocards_anki/package.py</code> <pre><code>class Package(PydanticTask):\n\"\"\"Create an Anki package.\n    Attributes:\n        path: Path (directory + filename) of the output `*.apkg` file.\n    \"\"\"\npath: Path = Path(\"out.apkg\")\n_notes: Dict[Deck, Dict[NoteType, List[NoteDict]]] = pydantic.PrivateAttr(\ndefaultdict(lambda: defaultdict(lambda: []))\n)\ndef start(self):\nlogger.debug(\"Anki packaging `start` method.\")\ndef process_one(self, note: NoteDict) -&gt; NoteDict:\nlogger.debug(f\"Processing Anki note {note}\")\ndeck = note[\"deck\"]\nnote_type = note[\"note_type\"]\nself._notes[deck][note_type] += [note]\nreturn note\ndef end(self):\nlogger.debug(\"Anki packaging `end` method.\")\ngenanki_decks: List[genanki.Deck] = []\nmedia_files: list[str] = []\nfor deck, types2notes in self._notes.items():\ngenanki_deck = genanki.Deck(deck.id, deck.name)\nfor note_type, notes in types2notes.items():\nfields = [\ni\nfor i in note_type.model.__fields__\nif i not in models.Note.__fields__\n]\ngenanki_note_type = genanki.Model(\nget_hash_id(note_type.id, 7),\nnote_type.name,\n[{\"name\": i} for i in fields],\ntemplates=[\n{\"name\": i.name, \"qfmt\": i.front, \"afmt\": i.back}\nfor i in note_type.card_sides\n],\ncss=note_type.css,\n)\nfor i in notes:\nfield_values = [i[j] for j in fields]\ngenanki_note = NoteID(\ni[\"id\"],\nmodel=genanki_note_type,\nfields=field_values,\ntags=i[\"tags\"],\n)\ngenanki_deck.add_note(genanki_note)\nmedia_files.extend(i[\"media_files\"])\ngenanki_decks.append(genanki_deck)\npackage = genanki.Package(genanki_decks, media_files)\npackage.write_to_file(str(self.path))\n</code></pre>"},{"location":"apis/mnemocards_anki/#mnemocards_anki.pronounce","title":"<code>pronounce</code>","text":""},{"location":"apis/mnemocards_anki/#mnemocards_anki.pronounce.Pronounce","title":"<code>Pronounce</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Pronounce text in a note attribute.</p> <p>Attributes:</p> Name Type Description <code>language</code> <code>pydantic.constr(to_lower=True)</code> <p>Two-letter code of the language to use in the pronunciation.</p> <code>attribute_to_pronounce</code> <code>str</code> <p>Note attribute to pronounce.</p> <code>append_media_file_to</code> <code>str</code> <p>Append generated media file path to a list attribute. This is needed for later steps that want to access the media files. For example, to package notes in an APKG we need to know where the media files are stored in order to include them in the APKG.</p> <code>output_dir</code> <code>str</code> <p>Output directory where generated files will be stored. This directory is relative to the configuration file.</p> Source code in <code>src/mnemocards_anki/pronounce.py</code> <pre><code>class Pronounce(PydanticTask):\n\"\"\"Pronounce text in a note attribute.\n    Attributes:\n        language: [Two-letter\n            code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) of the\n            language to use in the pronunciation.\n        attribute_to_pronounce: Note attribute to pronounce.\n        append_media_file_to: Append generated media file path to a list\n            attribute. This is needed for later steps that want to access the\n            media files. For example, to package notes in an APKG we need to\n            know where the media files are stored in order to include them in\n            the APKG.\n        output_dir: Output directory where generated files will be stored. This\n            directory is relative to the configuration file.\n    \"\"\"\nlanguage: pydantic.constr(to_lower=True)  # type: ignore\nattribute_to_pronounce: str = \"language_you_learn_word\"\nappend_media_file_to: str = \"media_files\"\nappend_pronunciation_to: str = \"\"\noutput_dir: str = \"./media_files\"\n@pydantic.validator(\"append_pronunciation_to\", always=True)\ndef default_append_pronunciation_to(cls, value, values):\nif not value:\nreturn values.get(\"attribute_to_pronounce\")\nreturn value\ndef start(self):\nif not os.path.exists(self.output_dir):\nos.makedirs(self.output_dir)\ndef process_one(self, note):\nto_pronounce = note[self.attribute_to_pronounce]\n# TODO: check if this is needed.\n# to_pronounce = remove_parentheses(to_pronounce)\nif self.language == \"ja\":\n# If you leave those spaces you get wrong pronunciations, like in\n# `\u30b9\u30da\u30a4\u30f3 \u4eba`. Instead of `supein jin` it pronounces it as\n# `supein hito` because the kanji `\u4eba` alone is pronounced as\n# `hito`.\nto_pronounce = remove_spaces(to_pronounce)\nhash_text = utils.get_hash_id(to_pronounce, bytes=8)\nsound_file = f\"{self.output_dir}/{hash_text}.mp3\"\nif not os.path.exists(sound_file):\nlogger.debug(\nf\"Creating audio file `{sound_file}` pronouncing `{to_pronounce}`.\"\n)\ntts = gTTS(to_pronounce, lang=self.language)\ntts.save(sound_file)\nnote[self.append_pronunciation_to] += f\" [sound:{hash_text}.mp3]\"\nnote[self.append_media_file_to].append(sound_file)\nreturn note\n</code></pre>"},{"location":"apis/mnemocards_essentials/","title":"mnemocards_essentials","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials","title":"<code>mnemocards_essentials</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.append_to_property","title":"<code>append_to_property</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.append_to_property.AppendToProperty","title":"<code>AppendToProperty</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Append an item to a property of type list.</p> <p>Provide a collection of pairs consisting of a name and its corresponding value, where the name represents the note property to which we wish to add the value.</p> <p>Configuration example:</p> <pre><code>- task: AppendToProperty\nnote_property_list: value to append\nanother_not_property_list: another value to append\n</code></pre> <p>If the given property is not a list you will get an error.</p> Source code in <code>src/mnemocards_essentials/append_to_property.py</code> <pre><code>class AppendToProperty(PydanticTask):\n\"\"\"Append an item to a property of type list.\n    Provide a collection of pairs consisting of a name and its corresponding\n    value, where the name represents the note property to which we wish to add\n    the value.\n    Configuration example:\n    ```yaml\n    - task: AppendToProperty\n      note_property_list: value to append\n      another_not_property_list: another value to append\n    ```\n    If the given property is not a list you will get an error.\n    \"\"\"\n_property_value_map: Dict[str, Any] = {}\n@pydantic.root_validator(pre=True)\n@classmethod\ndef build_extra(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]:\nproperty_value_map: Dict[str, Any] = {}\nfor field_name in list(values):\nproperty_value_map[field_name] = values.pop(field_name)\nvalues[\"_property_value_map\"] = property_value_map\nreturn values\ndef process_one(self, note: NoteDict) -&gt; NoteDict:\nfor k, v in self._property_value_map.items():\nvalue = note.get(k, [])\nvalue.append(v)\nnote[k] = value\nreturn note\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.directory","title":"<code>directory</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.directory.Directory","title":"<code>Directory</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a pipeline object from another directory.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path to the root directory in which the configuration file is. You can also specify a different configuration name.</p> Source code in <code>src/mnemocards_essentials/directory.py</code> <pre><code>class Directory(PydanticTask):\n\"\"\"Read a pipeline object from another directory.\n    Attributes:\n        path: Path to the root directory in which the configuration file is.\n            You can also specify a different configuration name.\n    \"\"\"\npath: Path\n_task: Task = pydantic.PrivateAttr()\ndef start(self):\nlogger.debug(\"Directory `start` method.\")\nself._task = runner.create_task(self.path)\nself._task.start()\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\nlogger.debug(\"Directory `process` method.\")\nreturn self._task.process(notes)\ndef end(self):\nlogger.debug(\"Directory `end` method.\")\nself._task.end()\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.git","title":"<code>git</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.pipeline","title":"<code>pipeline</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.pipeline.Pipeline","title":"<code>Pipeline</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Basic Mnemocards tasks that represents a sequence of tasks.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>Optional[str]</code> <p>Optional pipeline name.</p> <code>steps</code> <code>List[Task]</code> <p>List of Mnemocards tasks included in this pipelines.</p> Source code in <code>src/mnemocards_essentials/pipeline.py</code> <pre><code>class Pipeline(PydanticTask):\n\"\"\"Basic Mnemocards tasks that represents a sequence of tasks.\n    Attributes:\n        name: Optional pipeline name.\n        steps: List of Mnemocards tasks included in this pipelines.\n    \"\"\"\nname: Optional[str] = None\nsteps: List[Task]\n@pydantic.validator(\"steps\")\n@classmethod\ndef validate_at_least_one_step(cls, value):\nif value is not None and not len(value):\nraise ValueError(\"Pipelines should have at least one step.\")\nreturn value\ndef __len__(self) -&gt; int:\nreturn len(self.steps)\ndef start(self):\nfor i in self.steps:\ni.start()\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\nfor task in self.steps:\nnotes = task.process(notes)\nyield from notes\ndef end(self):\nfor i in self.steps:\ni.end()\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.print","title":"<code>print</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.print.Print","title":"<code>Print</code>","text":"<p>         Bases: <code>task.Task</code>, <code>pydantic.BaseModel</code></p> <p>Print every processed note in the terminal.</p> <p>Attributes:</p> Name Type Description <code>format_</code> <code>PrintFormat</code> <p>Format to use when printing the notes.</p> <code>sort_keys</code> <code>bool</code> <p>Show note properties sorted alphabetically.</p> <code>ignore_regex</code> <code>Optional[Pattern]</code> <p>If any note property match this regex it will not be included in the printed note.</p> Source code in <code>src/mnemocards_essentials/print.py</code> <pre><code>class Print(task.Task, pydantic.BaseModel):\n\"\"\"Print every processed note in the terminal.\n    Attributes:\n        format_: Format to use when printing the notes.\n        sort_keys: Show note properties sorted alphabetically.\n        ignore_regex: If any note property match this regex it will not be\n            included in the printed note.\n    \"\"\"\nformat_: PrintFormat = pydantic.Field(PrintFormat.YAML, alias=\"format\")\nsort_keys: bool = False\nignore_regex: Optional[Pattern] = None\n_count: int = pydantic.PrivateAttr(0)\n@pydantic.validator(\"ignore_regex\", pre=True)\n@classmethod\ndef compile_regex(cls, value):\nif value is not None:\nvalue = re.compile(value)\nreturn value\ndef process_one(self, note: NoteDict) -&gt; NoteDict:\nif self.ignore_regex is not None:\nnote = {\nk: v for k, v in note.items() if not self.ignore_regex.match(k)\n}\nconsole = Console()\nif self.format_ == PrintFormat.YAML:\ncode = yaml.dump(\nnote, allow_unicode=True, sort_keys=self.sort_keys\n).strip()\nelif self.format_ == PrintFormat.JSON:\ncode = json.dumps(\nnote, ensure_ascii=False, sort_keys=self.sort_keys, indent=2\n)\nelse:\nraise NotImplementedError()\npretty = Syntax(code, self.format_)\npanel = Panel.fit(pretty, title=f\"Note {self._count}\")\nconsole.print(panel)\nself._count += 1\nreturn note\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.print.PrintFormat","title":"<code>PrintFormat</code>","text":"<p>         Bases: <code>str</code>, <code>Enum</code></p> <p>Possible formats that can be used in <code>Print</code>.</p> Source code in <code>src/mnemocards_essentials/print.py</code> <pre><code>class PrintFormat(str, Enum):\n\"\"\"Possible formats that can be used in [`Print`][mnemocards_essentials.print.Print].\"\"\"\nYAML = \"yaml\"\nJSON = \"json\"\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_csv","title":"<code>read_csv</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_csv.ReadCsv","title":"<code>ReadCsv</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a CSV file.</p> <p>Comma-separated values (CSV) is a simple, text-based file format for storing tabular data. Records are separated by newlines, and values within a record are separated by comma <code>,</code> characters.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the CSV file to read.</p> <code>options</code> <code>dict[str, Any]</code> <p>Extra parameters to pass to the python <code>csv.DictReader</code>.</p> Source code in <code>src/mnemocards_essentials/read_csv.py</code> <pre><code>class ReadCsv(PydanticTask):\n\"\"\"Read a CSV file.\n    Comma-separated values (CSV) is a simple, text-based file format for\n    storing tabular data. Records are separated by newlines, and values within\n    a record are separated by comma `,` characters.\n    Attributes:\n        path: Path (directory + filename) of the CSV file to read.\n        options: Extra parameters to pass to the python `csv.DictReader`.\n    \"\"\"\npath: Path\noptions: dict[str, Any] = {}\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\nfile = open(self.path, \"r\")\nrows = csv.DictReader(file, **self.options)\nreturn itertools.chain(notes, rows)\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_json","title":"<code>read_json</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_json.ReadJson","title":"<code>ReadJson</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a JSON file.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the JSON file to read.</p> Source code in <code>src/mnemocards_essentials/read_json.py</code> <pre><code>class ReadJson(PydanticTask):\n\"\"\"Read a JSON file.\n    Attributes:\n        path: Path (directory + filename) of the JSON file to read.\n    \"\"\"\npath: Path\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\nfile = open(self.path, \"r\")\nrows = json.load(file)\nreturn itertools.chain(notes, rows)\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_toml","title":"<code>read_toml</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_toml.ReadToml","title":"<code>ReadToml</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a TOML file.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the TOML file to read.</p> <code>options</code> <code>dict[str, Any]</code> <p>Extra parameters to pass to the <code>toml.loads</code> function.</p> Source code in <code>src/mnemocards_essentials/read_toml.py</code> <pre><code>class ReadToml(PydanticTask):\n\"\"\"Read a TOML file.\n    Attributes:\n        path: Path (directory + filename) of the TOML file to read.\n        options: Extra parameters to pass to the `toml.loads` function.\n    \"\"\"\npath: Path\noptions: dict[str, Any] = {}\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\nfile = open(self.path, \"r\")\ndictionary = toml.load(file, **self.options)\nrows = _get_first_list_property(dictionary)\nreturn itertools.chain(notes, rows)\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_tsv","title":"<code>read_tsv</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_tsv.ReadTsv","title":"<code>ReadTsv</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a TSV file.</p> <p>Tab-separated values (TSV) is a simple, text-based file format for storing tabular data. Records are separated by newlines, and values within a record are separated by tab characters.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the TSV file to read.</p> <code>options</code> <code>dict[str, Any]</code> <p>Extra parameters to pass to the python <code>csv.DictReader</code>.</p> Source code in <code>src/mnemocards_essentials/read_tsv.py</code> <pre><code>class ReadTsv(PydanticTask):\n\"\"\"Read a TSV file.\n    Tab-separated values (TSV) is a simple, text-based file format for storing\n    tabular data. Records are separated by newlines, and values within a record\n    are separated by tab characters.\n    Attributes:\n        path: Path (directory + filename) of the TSV file to read.\n        options: Extra parameters to pass to the python `csv.DictReader`.\n    \"\"\"\npath: Path\noptions: dict[str, Any] = {}\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\nfile = open(self.path, \"r\")\nself.options.setdefault(\"delimiter\", \"\\t\")\nrows = csv.DictReader(file, **self.options)\nreturn itertools.chain(notes, rows)\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_xml","title":"<code>read_xml</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_xml.ReadXml","title":"<code>ReadXml</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a XML file.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the XML file to read.</p> Source code in <code>src/mnemocards_essentials/read_xml.py</code> <pre><code>class ReadXml(PydanticTask):\n\"\"\"Read a XML file.\n    Attributes:\n        path: Path (directory + filename) of the XML file to read.\n    \"\"\"\npath: Path\noptions: dict[str, Any] = {}\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\ncontent = open(self.path, \"r\").read()\ndictionary = xmltodict.parse(content, **self.options)\nrows = _get_first_list_property(_get_first_list_property(dictionary))\nreturn itertools.chain(notes, rows)\n</code></pre>"},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_yaml","title":"<code>read_yaml</code>","text":""},{"location":"apis/mnemocards_essentials/#mnemocards_essentials.read_yaml.ReadYaml","title":"<code>ReadYaml</code>","text":"<p>         Bases: <code>PydanticTask</code></p> <p>Read a YAML file.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path (directory + filename) of the YAML file to read.</p> Source code in <code>src/mnemocards_essentials/read_yaml.py</code> <pre><code>class ReadYaml(PydanticTask):\n\"\"\"Read a YAML file.\n    Attributes:\n        path: Path (directory + filename) of the YAML file to read.\n    \"\"\"\npath: Path\ndef process(self, notes: Iterable[NoteDict]) -&gt; Iterable[NoteDict]:\ncontent = open(self.path, \"r\").read()\nrows = yaml.safe_load(content)\nreturn itertools.chain(notes, rows)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Full list of examples:</p> <ul> <li>Custom Anki note. You will learn how to create a custom Anki note to fit your needs.</li> <li> WIP Markdown card fence. This example will contain information about how to generate cards from markdown that can also be rendered by Mkdocs (the library used for generating this docs).</li> <li>Plugins. You will learn how to create custom Mnemocards task from scratch.</li> <li>Pronunciation. You will learn how to create vocabulary notes with pronunciations from Google Translator.</li> </ul>"},{"location":"examples/custom_anki_note/","title":"Custom Anki note","text":"<p>This example shows how to create a custom Anki card type. The data used is a list of food additives, with their name, code and toxicity. The fields name, code and toxicity are not present in vocabulary note types, so we need to create a custom Anki note.</p> <p>Additives XML table has been created using the table from the www.aditivos-alimentarios.com website (Spanish).</p> <p>No docs yet, but you can explore the code in the repo.</p>"},{"location":"examples/markdown_card_fence/","title":"[WIP] Markdown Card Fence","text":"<p>Work In Progress</p> <p>This page will contain an example on how to embed cards in markdown files. Using a markdown plugin we can also generate HTML code from our cards.</p> Generated HTMLMarkdown source code <p>This is some markdown file. You can embed cards inside markdown using the following syntax:</p> <p>id: 12345 tags: tag0, tag1</p> <p>Title</p> <p>Back</p> <pre><code>This is some **markdown** file. You can embed cards inside markdown using\nthe following syntax:\n\n&lt;&lt;&lt;\nid: 12345\ntags: tag0, tag1\n===\nTitle\n---\nBack\n&gt;&gt;&gt;\n</code></pre>"},{"location":"examples/markdown_card_fence/#features","title":"Features","text":"<ul> <li>Build several cards inside the same Markdown file.</li> <li>Include extra content in the markdown file that will not be included in a card.</li> <li>Visualize your cards outside Anki using Mkdocs.</li> <li>Search your cards database using the build-in Mkdocs search tool.</li> <li>Cards database easy to publish thanks to Mkdocs.</li> </ul>"},{"location":"examples/plugins/","title":"Plugins","text":"<p>This example will demonstrate how to create custom Mnemocards tasks to process your flashcards in any way you desire.</p> <p>Warning</p> <p>This example assumes a basic knowledge of Python. If you are not familiar with Python, it is recommended that you first learn the basics of the language before attempting to create custom Mnemocards tasks.</p> <p>We will be generating a sequence of numbers using a for loop, multiplying each number by a factor of 2, and then printing the resulting numbers. All that using custom Mnemocards tasks.</p> <p>Example</p> <p>You can find the final source code for this example in the repo.</p>"},{"location":"examples/plugins/#setup","title":"Setup","text":"<p>The custom tasks will be defined in a <code>plugins.py</code> Python module, located in the same directory as your <code>mnemocards.yaml</code> configuration file.</p> <p>Warning</p> <p>The name <code>plugins.py</code> is arbitrary, and you can choose any name you prefer. However, some names may hide existing Python modules, so using names like <code>os</code>, <code>sys</code>, or <code>mnemocards</code> for your plugin file would be problematic.</p> <p>As the first step, create an empty directory for this example. Inside that directory, create two empty files: <code>mnemocards.yaml</code> and <code>plugins.py</code>.</p>"},{"location":"examples/plugins/#data-source","title":"Data source","text":"<p>Every Mnemocards pipeline usually begins with a task that reads data from a source. Without data in our pipeline, there would be nothing to process. Therefore, the first thing we are going to do in our example is to create a task that injects cards into the main pipeline.</p> <p>It is common to read information from a file or a web resource, but to simplify the example, we will simply generate a series of consecutive numbers.</p> plugins.py<pre><code>from mnemocards import Task\nclass NumberGenerator(Task):\n\"\"\"Yield a series of numbers.\"\"\"\ndef process(self, _):\nfor i in range(3):\nyield {\"number\": i}\n</code></pre> <p>To create a custom task, you will first define a class that extends the <code>mnemocards.Task</code> base class. In this class, you can implement the process method to perform any transformations on the input data or generate new input data. You can also implement the <code>start</code> and <code>end</code> methods to perform any setup and teardown tasks that your task requires.</p> <p>Once you have defined your custom task class, you can use it in your <code>mnemocards.yaml</code> configuration file by specifying the fully qualified class name as the task type. Update your config file with the following content:</p> mnemocards.yaml<pre><code>steps:\n- type: plugin.NumberGenerator\n- type: Print\n</code></pre> <p>In this configuration file we are telling Mnemocards that we want to run our number generator first and then, just to make sure it is working correctly, we print each of the generated dictionaries.</p> <p>If you run <code>mnemocards run</code> from a terminal in the project directory, you will see an output similar to:</p> <pre><code>$ mnemocards run\n\u2554\u2566\u2557\u2554\u2557\u2554\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2500\u2510\u252c\u2500\u2510\u250c\u252c\u2510\u250c\u2500\u2510\n\u2551\u2551\u2551\u2551\u2551\u2551\u2551\u2563 \u2551\u2551\u2551\u2551 \u2551\u2502  \u251c\u2500\u2524\u251c\u252c\u2518 \u2502\u2502\u2514\u2500\u2510\n\u2569 \u2569\u255d\u255a\u255d\u255a\u2550\u255d\u2569 \u2569\u255a\u2550\u255d\u2514\u2500\u2518\u2534 \u2534\u2534\u2514\u2500\u2500\u2534\u2518\u2514\u2500\u2518 1.0.0a0\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 I have a photographic memory... I need to take a photograph to remember anything. \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nHi! \ud83d\udc4b\nLooking for config files... \ud83d\udcc3\n\u2728  Valid task found in `mnemocards.yaml` \u2728\n\u256d\u2500 Note 0 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 1 \u2500\u2500\u256e\n\u2502 number: 1 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 2 \u2500\u2500\u256e\n\u2502 number: 2 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nSee you soon! \ud83e\udd19.\n</code></pre>"},{"location":"examples/plugins/#configuration-parameters","title":"Configuration parameters","text":"<p>In the previous section, we generated a fixed number of cards using a hardcoded value inside the Python <code>range</code> function. However, we may want to change this value from our configuration file.</p> <p>To achieve this, we can modify the <code>NumberGenerator</code> class to accept a parameter <code>numbers_to_generate</code> which defaults to 3. We can then use this parameter to control the number of cards to generate.</p> plugins.py<pre><code>from mnemocards import Task\nclass NumberGenerator(Task):\n\"\"\"Yield a series of numbers.\"\"\"\ndef __init__(self, numbers_to_generate=3):\nself.numbers_to_generate = numbers_to_generate\ndef process(self, _):\nfor i in range(self.numbers_to_generate):\nyield {\"number\": i}\n</code></pre> <p>If we do not modify our previous config file, <code>numbers_to_generate</code> will take the default value of 3, so the output will be the same.</p> <p>Now, we can use this parameter in our YAML configuration file. In the following example, we set <code>numbers_to_generate</code> to 2:</p> mnemocards.yaml<pre><code>steps:\n- type: plugin.NumberGenerator\nnumbers_to_generate: 2\n- type: Print\n</code></pre> <p>The output of this pipeline shows that only two cards were generated:</p> <pre><code>\u256d\u2500 Note 0 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 1 \u2500\u2500\u256e\n\u2502 number: 1 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>By changing the value of <code>numbers_to_generate</code> in our YAML configuration file, we can easily control the number of cards generated by our pipeline. Any other parameter present in our YAML file will be passed to the <code>__init__</code> method.</p>"},{"location":"examples/plugins/#upstream-cards","title":"Upstream cards","text":"<p>Our implementation has a problem. Try to run this configuration file:</p> mnemocards.yaml<pre><code>steps:\n- type: plugin.NumberGenerator\nnumbers_to_generate: 1\n- type: plugin.NumberGenerator\nnumbers_to_generate: 1\n- type: Print\n</code></pre> <p>We may think that we should get two cards, one from each generator:</p> <pre><code>\u256d\u2500 Note 0 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 1 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>However, what we actually get is:</p> <pre><code>\u256d\u2500 Note 0 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>This card is generated by our second <code>NumberGenerator</code>, but the card from the first one is not reaching the <code>Print</code> task. Why? This is because the <code>process</code> method that we are using to inject data also receives an iterable of elements that come from the previous task. At the moment, we are completely ignoring the first argument of <code>process</code>, so if we want our generator not to ignore the previous cards, we need to modify our class as follows:</p> plugins.py<pre><code>from mnemocards import Task\nclass NumberGenerator(Task):\n\"\"\"Yield a series of numbers.\"\"\"\ndef __init__(self, numbers_to_generate=3):\nself.numbers_to_generate = numbers_to_generate\ndef process(self, notes):\nyield from notes\nfor i in range(self.numbers_to_generate):\nyield {\"number\": i}\n</code></pre> <p>Now we are giving a name to the notes parameter and we are making our generator return all the notes/dictionaries generated by the previous tasks first, and then inject its own. This way, the output will be as expected:</p> <pre><code>$ mnemocards run\n\u2554\u2566\u2557\u2554\u2557\u2554\u2554\u2550\u2557\u2554\u2566\u2557\u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2500\u2510\u252c\u2500\u2510\u250c\u252c\u2510\u250c\u2500\u2510\n\u2551\u2551\u2551\u2551\u2551\u2551\u2551\u2563 \u2551\u2551\u2551\u2551 \u2551\u2502  \u251c\u2500\u2524\u251c\u252c\u2518 \u2502\u2502\u2514\u2500\u2510\n\u2569 \u2569\u255d\u255a\u255d\u255a\u2550\u255d\u2569 \u2569\u255a\u2550\u255d\u2514\u2500\u2518\u2534 \u2534\u2534\u2514\u2500\u2500\u2534\u2518\u2514\u2500\u2518 1.0.0\n\u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 My memory is so bad, I could plan my own surprise birthday party and still be surprised. \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nHi! \ud83d\udc4b\nLooking for config files... \ud83d\udcc3\n\u2728  Valid task found in `mnemocards.yaml` \u2728\n\u256d\u2500 Note 0 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 1 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\nSee you soon! \ud83e\udd19\n</code></pre>"},{"location":"examples/plugins/#process-notes","title":"Process notes","text":"<p>Our previous task generates data. Let's create a task that just process the existing data. In the same <code>plugins.py</code> file add the following class:</p> plugins.py<pre><code>class NumberDouble(Task):\n\"\"\"Create a `double` property with the value of `number` multiply by 2.\"\"\"\ndef process(self, notes):\nfor note in notes:\nnote[\"double\"] = note[\"number\"] * 2\nyield note\n</code></pre> <p>In the <code>mnemocards.yaml</code> file, include the following steps:</p> mnemocards.yaml<pre><code>steps:\n- type: plugin.NumberGenerator\nnumbers_to_generate: 3\n- type: plugin.NumberDouble\n- type: Print\n</code></pre> <p>The printed cards should be:</p> <pre><code>\u256d\u2500 Note 0 \u2500\u2500\u256e\n\u2502 number: 0 \u2502\n\u2502 double: 0 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 1 \u2500\u2500\u256e\n\u2502 number: 1 \u2502\n\u2502 double: 2 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Note 2 \u2500\u2500\u256e\n\u2502 number: 2 \u2502\n\u2502 double: 4 \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre> <p>To simplify the code, you can overwrite the <code>process_one</code> method instead of process. This method receives one note at a time instead of an iterable with all the upstream notes:</p> plugins.py<pre><code>class NumberDouble(Task):\n\"\"\"Create a `double` property with the value of `number` multiply by 2.\"\"\"\ndef process_one(self, note):\nnote[\"double\"] = note[\"number\"] * 2\nreturn note\n</code></pre> <p>The result should be exactly the same.</p>"},{"location":"examples/plugins/#sink-tasks","title":"Sink tasks","text":"<p>In addition to generating and processing cards, it is also necessary to produce something with them. For instance, creating Anki decks. The Print function we have been using throughout this tutorial is also a way to perform an action with the pipeline data.</p> <p>The following is an example of a custom print task, which inherits from the Task class and defines a <code>process_one</code> method that takes a note as input. The note is a dictionary containing the number and double fields.</p> plugins.py<pre><code>class NumberPrint(Task):\n\"\"\"Print number notes in a custom way.\"\"\"\ndef process_one(self, note):\nnumber = note[\"number\"]\ndouble = note[\"double\"]\nprint(f\"Number {number}, double {double}\")\nreturn note\n</code></pre> <p>Note</p> <p>The <code>return note</code> is needed to keep the flow of notes. If no return is used the notes are not going to survive after the <code>NumberPrint</code> task. In other words, our task will act as a filter.</p> <p>The task is then added to the pipeline along with the previously defined <code>NumberGenerator</code> and <code>NumberDouble</code> tasks:</p> mnemocards.yaml<pre><code>steps:\n- type: plugin.NumberGenerator\nnumbers_to_generate: 3\n- type: plugin.NumberDouble\n- type: plugin.NumberPrint\n</code></pre> <p>Finally, running the pipeline produces the following output:</p> <pre><code>Number 0, double 0\nNumber 1, double 2\nNumber 2, double 4\n</code></pre>"},{"location":"examples/plugins/#complete-code","title":"Complete code","text":"<p>See the complete code in the repo.</p>"},{"location":"examples/plugins/#conclusion","title":"Conclusion","text":"<p>Using custom tasks in Mnemocards allows you to tailor the card processing pipeline to your specific needs. For example, you can create tasks to automatically generate pronunciations, add images or audio files, or perform complex text processing operations. The possibilities are endless, and with Mnemocards, you have the power to customize your flashcard creation process in any way you see fit.</p>"},{"location":"examples/plugins/#plugins_1","title":"Plugins","text":"<p>This example will demonstrate how to create custom Mnemocards tasks to process your flashcards in any way you desire.</p> <p>Read a detailed tutorial of this example in the official docs.</p>"},{"location":"examples/pronunciation/","title":"Pronunciation","text":"<p>This example shows how to add pronunciation to our language learning flashcards. This examples is described in the Overview page.</p>"},{"location":"meps/mep00/","title":"MEP 0 - Mnemocards Enhancement Proposals","text":"Authors:                      guiferviz                  Status:               \u2705 Active           Created: 2023-01-20 Version: 0.0.1 <p>This first MEP introduces MEPs. Here we define what MEPs are, what process should be followed to propose one and what information they should contain.</p>"},{"location":"meps/mep00/#what-is-a-mep","title":"What is a MEP?","text":"<p>MEP stands for Enhancement Proposal. A MEP is a design document providing information to the Mnemocards community, or describing a new feature for Mnemocards or its processes or environment. MEP is to Mnemocards what PEP is to Python. In fact, the first two sentences of this paragraph are an adaptation of the first lines of PEP 1 .</p>"},{"location":"meps/mep00/#creation-process","title":"Creation process","text":"<p>At the moment, the creation process is very simple:</p> <ol> <li>Create a new file inside <code>docs/eps</code>. The number of the new MEP should be chosen by adding 1 to the last existing MEP.</li> <li>Copy the header macro of this MEP and update the different values. Learn how to set the status in the following flow diagram.</li> <li>Write the document. See more about this point in the following section.</li> <li>Publish a PR to start the review/discussion.</li> </ol> <p>Flow diagram that defines how to set an status:</p> <pre><code>graph TD\n    Q{Required implementation?} --&gt;|No| A[Active]\n    Q --&gt;|Yes| P[Planned]\n    P --&gt;|when implemented| A\n    P --&gt;|when no longer valid| D[Deprecated]\n    A --&gt;|when no longer valid| D</code></pre>"},{"location":"meps/mep00/#what-a-mep-should-contain","title":"What a MEP should contain?","text":"<p>MEP files should be written in a friendly way, without assuming too much knowledge on the part of the reader. It is a technical document, but technical terms should not be abused.</p> <p>A common structure is not required, just make sure it is comprehensible. Include an abstract after the metadata table at the beginning and organise the article into sections of your choice.</p>"},{"location":"tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"}]}